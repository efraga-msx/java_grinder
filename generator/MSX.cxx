/**
 *  Java Grinder
 *  Author: Michael Kohn
 *   Email: mike@mikekohn.net
 *     Web: http://www.mikekohn.net/
 * License: GPL
 *
 * Copyright 2014-2016 by Michael Kohn
 *
 */


/*
 *   MSX support by Giovanni Nunes - https://github.com/plainspooky
 *                  Emiliano Fraga - https://github.com/efraga-msx
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

#include "MSX.h"

// enable or disable a more verbose generation of assembly code
#define VERBO 1

MSX::MSX() :
  need_ldirvv(false),
  need_change_colors(false)
{
  /*
        MSX memory layout in 16KiB blocks:

        0x0000 -- 0x3FFF : MSX-BIOS
        0x4000 -- 0x7FFF : Code generated by Java Grinder
        0x8000 -- 0xBFFF : Code generated by Java Grinder
        0xC000 -- 0xFFFF : RAM* (don't touch in the last 4KiB!)

        (*) in MSX models with 8KiB of RAM this page begin at 0xE000
  */
}

MSX::~MSX()
{
  fprintf(out,"\n"
  "; -- The program was ended.\n"
  "\n"
  "; -- Libraries will be appended at this point... --\n\n");

  // insert_init_env();

  // the need_* will be here
  if (need_ldirvv) { insert_ldirvv(); }
  if (need_change_colors) { insert_changecolors(); }

  for (int i = 0; i < _REQ_MSX_MAX; i++)
  {
    if (requirables[i]->isActive())
    {
      fprintf(out, "  .include \"%s\"\n", requirables[i]->getStr());
    }
    delete requirables[i];
  }

  fprintf(out,"\n"
  "__JAVA_END:\n"
  "\n"
  "; -- end of code! ^_^ --\n");
}

int MSX::open(const char *filename)
{
  if (Z80::open(filename) != 0) { return -1; }

  // include labels from BIOS calls and system variables
  fprintf(out, ".include \"msx.inc\"\n");

  //
  // this must be checked! double checked!!
  //
  fprintf(out, "ram_start equ 0xc000\n");
  fprintf(out, "heap_ptr equ ram_start\n");
  fprintf(out, "save_iy equ heap_ptr\n");
  //
  // this must be checked! double checked!!
  //

  return 0;
}

int MSX::start_init()
{
  fprintf(out,"__JAVA_START:\n");

  // cartridge header
  fprintf(out,"\n"
  "  .org 0x4000\n"                 // My program start at 0x4000 (16384)
  "  .db \"AB\"\n"                  // 'AB' = ROM Cartridge ID
  "  .dw __JAVA_EXEC\n"             // START ADDRESS
  "  .dw 0x0000\n"                  // STATMENT (not used)
  "  .dw 0x0000\n"                  // DEVICE (not used)
  "  .dw 0x0000\n"                  // TEXT (not used)
  "  .ds8 6\n"                      // RESERVED (do not use)
  "\n");

  // main label
  fprintf(out,"__JAVA_EXEC:\n"
  "  call __JAVA_CODE\n\n");

  // A pretty infinite loop to prevent return to unknow places
  fprintf(out,"\n"
  "__JAVA_LOOP:\n"
  "  jr __JAVA_LOOP\n"
  "\n"
  "; -- end of main block! ^_^ --\n");

  fprintf(out,"\n"
  "__JAVA_CODE:\n");

  // environment starts here
  // fprintf(out,"call __JAVA_INIT_ENV\n");

/*
    0x2b    7 6 5 4 3 2 1 0
            │ │ │ │ └─┴─┴─┴── Character set
            │ │ │ │           0 = Japanese, 1 = International, 2=Korean
            │ └─┴─┴────────── Date format
            │                 0 = Y-M-D, 1 = M-D-Y, 2 = D-M-Y
            └──────────────── Default interrupt frequency
                              0 = 60Hz, 1 = 50Hz

    0x2c   7 6 5 4 3 2 1 0
            │ │ │ │ └─┴─┴─┴── Keyboard type
            │ │ │ │           0 = Japanese, 1 = International
            │ │ │ │           2 = French (AZERTY), 3 = UK, 4 = German (DIN)
            └─┴─┴─┴────────── Basic version
                              0 = Japanese, 1 = International

    0x2d   0 = MSX1, 1 = MSX2, 2 = MSX2+, 3 = MSX turbo R ...

    0x2e   1 = build in MSX-MIDI ^_^
*/

  return 0;
}

/*
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *  Console (text-mode) operation using MSX-BIOS calls
 *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*/

// produces a 1316 Hz beep on speaker
int MSX::msx_beep()
{
  __VERBOSE

  __PUSH_BCDE
  fprintf(out,"  call BEEP\n");
  __POP_BCDE

  return 0;
}

// clear the screen and sets cursor to home at 0,0
int MSX::msx_cls()
{
   __VERBOSE

   __PUSH_BCDE
   fprintf(out,"  call CLS\n");
   __POP_BCDE

   return 0;
}

// set text cursor position -- method for variables
int MSX::msx_setCursor_II()
{
  __VERBOSE

  __POP_A_DE                        // get 'lin'
  fprintf(out,"  ld (CSRY), a\n");
  __POP_A_DE                        // get 'col'
  fprintf(out,"  ld (CSRX), a\n");

/*
    changing CSRY and CSRX the cursor position is made in a indirect way,
    use POSIT will be more correctly:

    __POP_A_DE  // A=column
    pop de      // E=line
    push hl
    ld l, e      // L = line
    ld h, a      // H = column
    call POSIT
    pop hl
*/
  return 0;
}

// ser text cursor position -- method for constants
int MSX::msx_setCursor_II(int col, int lin)
{
  __VERBOSE

  fprintf(out,"  ld a, 0x%02x\n", lin);
  fprintf(out,"  ld (CSRY), a\n");
  fprintf(out,"  ld a, 0x%02x\n", col);
  fprintf(out,"  ld (CSRX), a\n");

  return 0;
}

// display funciton keys content
int MSX::msx_keyOn()
{
  __VERBOSE

  __PUSH_BCDE
  fprintf(out,"  call DSPFNK\n");
  __POP_BCDE

  return 0;
}

// hide function keys content
int MSX::msx_keyOff()
{
  __VERBOSE

  fprintf(out,"  push bc\n");
  fprintf(out,"  call ERAFNK\n");
  fprintf(out,"  pop bc\n");

  return 0;
}

// set screen width -- method for variables
int MSX::msx_width_I()
{
  __VERBOSE

  __POP_A_DE                        // get 'w'
  fprintf(out,"  ld (LINLEN), a\n");

  return 0;
}

// set screen width -- method for constants
int MSX::msx_width_I(int w)
{
  __VERBOSE

  fprintf(out,"  ld a, 0x%02x\n", w);
  fprintf(out,"  ld (LINLEN), a\n");

  return 0;
}

// print a character on screen -- method for variables
int MSX::msx_putChar_C()
{
  __VERBOSE

  __POP_A_DE                        // get 'c'
  fprintf(out,"  call CHPUT\n");

  return 0;
}

// print a character on screen -- method for constants
int MSX::msx_putChar_C(char c)
{
  __VERBOSE

  fprintf(out,"  ld a, 0x%02x\n", c);
  fprintf(out,"  call CHPUT\n");

  return 0;
}

// wait until a key be pressed and put it on stack
int MSX::msx_getChar()
{
  __VERBOSE

  fprintf(out,"  call CHGET\n");
  __PUSH_HL_A

  return 0;
}

// not working :/
int MSX::msx_putS_IaC()
{
  __VERBOSE

//  fprintf(out,"  ;; putS_IaC\n");
//  fprintf(out,"  pop de\n");
//  fprintf(out,"  ld a, e\n");
//  fprintf(out, "  call CHPUT\n");

  return 0;
}

/*
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *  Specific MSX screen (VDP) functions using MSX-BIOS calls
 *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*/

// change foreground color -- method for variables
int MSX::msx_foreColor_I()
{
  // requirables[REQ_MSX_CHANGE_COLORS]->activate();
  need_change_colors = true;
  __VERBOSE

  __POP_A_DE                        // get 'color'
  //fprintf(out,"  and 15\n");
  fprintf(out,"  ld (FORCLR), a\n");
  fprintf(out,"  call CHANGE_COLORS\n");

  return 0;
}

// change foreground color -- method for constants
int MSX::msx_foreColor_I(int color)
{
  need_change_colors = true;
  __VERBOSE

  color = color & 15;

  fprintf(out,"  ld a, 0x%02x\n", color);
  fprintf(out,"  ld (FORCLR),a\n");
  fprintf(out,"  call CHANGE_COLORS\n");

  return 0;
}

// change background color -- method for variables
int MSX::msx_backColor_I()
{
  need_change_colors = true;
  __VERBOSE

  __POP_A_DE                        // get 'color'
  //fprintf(out,"  and 15\n");
  fprintf(out,"  ld (BAKCLR), a\n");
  fprintf(out,"  call CHANGE_COLORS\n");

  return 0;
}

// change background color -- method for constants
int MSX::msx_backColor_I(int color)
{
  need_change_colors = true;
  __VERBOSE

  color = color & 15;

  fprintf(out,"  ld a, 0x%02x\n", color);
  fprintf(out,"  ld (BAKCLR), a\n");
  fprintf(out,"  call CHANGE_COLORS\n");

  return 0;
}

// change border color -- method for variables
int MSX::msx_borderColor_I()
{
  need_change_colors = true;
  __VERBOSE

  __POP_A_DE                        // get 'color'
  //fprintf(out,"  and 15\n");
  fprintf(out,"  ld (BDRCLR), a\n");
  fprintf(out,"  call CHANGE_COLORS\n");

  return 0;
}

// change background color -- method for constants
int MSX::msx_borderColor_I(int color)
{
  need_change_colors = true;
  __VERBOSE

  color = color & 15;

  fprintf(out,"  ld a, 0x%02x\n", color);
  fprintf(out,"  ld (BDRCLR), a\n");
  fprintf(out,"  call CHANGE_COLORS\n");

  return 0;
}

// change foreground, background and border colors -- method for variables
int MSX::msx_color_III()
{
  need_change_colors = true;
  __VERBOSE

  __POP_A_DE
  //fprintf(out,"  and 15\n");
  fprintf(out,"  ld (BDRCLR), a\n");
  __POP_A_DE
  //fprintf(out,"  and 15\n");
  fprintf(out,"  ld (BAKCLR), a\n");
  __POP_A_DE
  //fprintf(out,"  and 15\n");
  fprintf(out,"  ld (FORCLR), a\n");
  fprintf(out,"  call CHANGE_COLORS\n");

  return 0;
}

// change foreground, background and border colors -- method for constants
int MSX::msx_color_III(int foreground, int background, int border)
{
  need_change_colors = true;
  __VERBOSE

  foreground = foreground & 15;     // foregound color
  background = background & 15;     // background color
  border = border & 15;             // border color

  fprintf(out,"  ld a, 0x%02x\n", border);
  fprintf(out,"  ld (BDRCLR), a\n");
  fprintf(out,"  ld a, 0x%02x\n", background);
  fprintf(out,"  ld (BAKCLR), a\n");
  fprintf(out,"  ld a, 0x%02x\n", foreground);
  fprintf(out,"  ld (FORCLR), a\n");
  fprintf(out,"  call CHANGE_COLORS\n");

  return 0;
}

// set screen mode -- method for variables
int MSX::msx_screen_I()
{
  __VERBOSE

  __POP_A_DE                        // get 'mode'
  __PUSH_BCHL
  fprintf(out,"  call CHMOD\n");
  __POP_BCHL

  return 0;
}

// set screen mode -- method for constants
int MSX::msx_screen_I(int mode)
{
  __VERBOSE

  mode = mode & 3;
  fprintf(out,"  ld a, 0x%02x\n", mode);
  __PUSH_BCDEHL
  fprintf(out,"  call CHGMOD\n");
  __POP_BCDEHL

  return 0;
}

// set a value of a VDP register -- method for variables
int MSX::msx_writeVDP_II()
{
  __VERBOSE

  __POP_A_DE                        // get 'value'
  fprintf(out,"  exx af, af'\n");
  __POP_A_DE                        // get 'reg'
  fprintf(out,"  push bc\n");
  fprintf(out,"  and 7\n");
  fprintf(out,"  ld c, a\n");
  fprintf(out,"  exx af, af'\n");
  fprintf(out,"  ld b, a\n");
  fprintf(out,"  call WRTVDP\n");
  fprintf(out,"  pop bc\n");

  return 0;
}

// set a value of a VDP register -- method for constants
int MSX::msx_writeVDP_II(int reg, int value)
{
  __VERBOSE

  reg = reg & 7;
  fprintf(out,"  push bc\n");
  fprintf(out,"  ld b, 0x%02x\n",value);
  fprintf(out,"  ld c, 0x%02x\n",reg);
  fprintf(out,"  call WRTVDP\n");
  fprintf(out,"  pop bc\n");

  return 0;
}

// write a byte in a VRAM address -- method for variables
int MSX::msx_writeVRAM_II()
{
  __VERBOSE

  __POP_A_DE                        // get 'value'
  fprintf(out,"  pop de\n");        // get 'addr'
  //fprintf(out,"  push hl\n");
  // exx af, af'
  // ld a, h
  // and 0x3f    // I don't know if WRTVRM checks VRAM address
  // ld h, a
  // exx af, af'
  fprintf(out,"  ld h, d\n");
  fprintf(out,"  ld l, e\n");
  fprintf(out,"  call WRTVRM\n");
  // fprintf(out,"  pop hl\n");    -- forget HL

  return 0;
}

// write a byte in a VRAM address -- method for constants (?)
int MSX::msx_writeVRAM_II(int addr, int value)
{
  __VERBOSE

  addr = addr & 0x3fff;             // limit to avoid wrong addresses
  value = value & 0xff;             // limit to 8-bit
  fprintf(out,"  push hl\n");
  fprintf(out,"  ld hl, 0x%02x\n",addr);
  fprintf(out,"  ld a, 0x%02x\n",value);
  fprintf(out,"  call WRTVRM\n");
  fprintf(out,"  pop hl\n");

  return 0;
}

// read a byte in a VRAM address -- method for variables
int MSX::msx_readVRAM_I()
{
  __VERBOSE

  fprintf(out,"  pop de\n");
  // ld a,d
  // and 0x3f    // I don't know if WRTVRM checks VRAM address
  // ld d,a
  fprintf(out,"  ld h, d\n");
  fprintf(out,"  ld l, e\n");
  fprintf(out,"  call RDVRM\n");
  __PUSH_HL_A

  return 0;
}

// read a byte in a VRAM address -- method for constants
int MSX::msx_readVRAM_I(int addr)
{
  __VERBOSE

  addr = addr & 0x3fff;             // limit to prevent wrong addresses
  fprintf(out,"  ld hl, 0x%02x\n",addr);
  fprintf(out,"  call RDVRM\n");
  __PUSH_HL_A

  return 0;
}

// read a value of VDP register -- method for variables
int MSX::msx_readVDP_I()
{
  __VERBOSE

  __POP_A_DE
  fprintf(out,"  and 7\n");         // MSX has only 8 VDP registers
  fprintf(out,"  call RDVDP\n");
  __PUSH_HL_A

  return 0;
}

// read a value of VDP register -- method for constants
int MSX::msx_readVDP_I(int reg)
{
  __VERBOSE

  reg = reg & 7;                    // MSX has only 8 VDP registers
  fprintf(out,"  ld a, 0x%02x\n",reg);
  fprintf(out,"  call RDVDP\n");
  __PUSH_HL_A

  return 0;
}

// fill a VRAM block with a value -- method for variavles (not functional)
int MSX::msx_fillVRAM_III()
{
  __VERBOSE

  // disabled

  return 0;
}

// fill a VRAM block with a value -- method for constants
int MSX::msx_fillVRAM_III(int value, int addr, int size)
{
  __VERBOSE

  __PUSH_BCHL
  value = value & 255;              // only bytes :-)
  addr = addr & 16383;              // limit to avoid wrong addresses
  size = size & 16383;              // limit to avoid wrong addresses
  fprintf(out,"  ld a, 0x%02x\n",value);
  fprintf(out,"  ld bc, 0x%02x\n",size);
  fprintf(out,"  ld hl, 0x%02x\n",addr);
  fprintf(out,"  call FILVRM\n");
  __POP_BCHL

  return 0;
}

// copies a range of VRAM to another part -- method for variables'
int MSX::msx_copyVRAM_III()
{
  __VERBOSE

  // disabled

  return 0;
}

// copies a range of VRAM to another part -- method for constants
int MSX::msx_copyVRAM_III(int source, int dest, int size)
{
  need_ldirvv = true;
  __VERBOSE

  size = size & 16383;          // limit to avoid wrong addresses
  source = source & 16383;      // limit to avoid wrong addresses
  dest = dest & 16383;          // limit to avoid wrong addresses
  __POP_BCDEHL
  fprintf(out,"  ld bc, 0x%02x\n",size);
  fprintf(out,"  ld de, 0x%02x\n",dest);
  fprintf(out,"  ld hl, 0x%02x\n",source);
  fprintf(out,"  call LDIRVV");
  __PUSH_BCDEHL

  return 0;
}

/*
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *  Specific MSX audio (PSG) functions using MSX-BIOS calls
 *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*/

// set a value of a PSG register -- method for variables
int MSX::msx_writePSG_II()
{
  __VERBOSE

  __POP_A_DE                        // get 'value' in A
  fprintf(out,"  and 15\n");
  fprintf(out,"  pop de\n");        // get 'reg' in E
  fprintf(out,"  ld d, e\n");       // send 'reg' to D
  fprintf(out,"  ld e, a\n");       // send 'value' to E
  fprintf(out,"  ld a, d\n");       // send 'reg' to A
  fprintf(out,"  call WRTPSG\n");
  fprintf(out,"  pop bc\n");

  return 0;
}

// set a value of a PSG register -- method for constants
int MSX::msx_writePSG_II(int reg, int value)
{
  __VERBOSE

  reg = reg & 15;
  fprintf(out,"  ld e, 0x%02x\n",value);
  fprintf(out,"  ld a, 0x%02x\n",reg);
  fprintf(out,"  call WRTPSG\n");

  return 0;
}

// get joystick position -- method for variables
int MSX::msx_getStick_I()
{
  __VERBOSE

  __POP_A_DE
  __PUSH_BCDEHL
  fprintf(out,"  call GTSTCK");
  __POP_BCDEHL
  __PUSH_HL_A

  return 0;
}

// get joystick position -- method for constants
int MSX::msx_getStick_I(int joy)
{
  __VERBOSE

  fprintf(out,"  ld a, 0x%02x\n",joy);
  __PUSH_BCDEHL
  fprintf(out,"  call GTSTCK");
  __POP_BCDEHL
  __PUSH_HL_A

  return 0;
}

// get joystick buttoms status -- method for variables
int MSX::msx_getTrig_I()
{
  __VERBOSE

  __POP_A_DE
  fprintf(out,"  push bc");
  fprintf(out,"  call GTTRIG");
  fprintf(out,"  pop bc");
  __PUSH_HL_A

  return 0;
}

// get joystick buttoms status -- method for constants
int MSX::msx_getTrig_I(int joy)
{
  __VERBOSE

  fprintf(out,"  ld a, 0x%02x\n",joy);
  fprintf(out,"  push bc");
  fprintf(out,"  call GTTRIG");
  fprintf(out,"  pop bc");
  __PUSH_HL_A

  return 0;
}

/*
 *  Support routines
 */
/*void MSX::insert_init_env(void)
{
  return 0;
}*/

void MSX::insert_changecolors(void)
{
  fprintf(out,"CHANGE_COLORS:\n"
  "  push bc\n"
  "  push hl\n"
  "  call CHGCLR\n"
  "  pop hl\n"
  "  pop bc\n"
  "  ret\n\n");
}

void MSX::insert_ldirvv(void)
{
  fprintf(out,"LDIRVV:\n"
  "  call RDVRM\n"
  "  ex de,hl\n"
  "  call WRTVRM\n"
  "  ex de,hl\n"
  "  inc de\n"
  "  cpi\n"
  "  jp PE,LDIRVV\n"
  "  ret\n\n");
}

// ------------ Requirable sub class ----

Requirable::Requirable (const char* str)
{
  m_b = false;
  m_str = str;
}

Requirable::~Requirable()
{
  printf("Requirable::~Requirable() : %s\n", m_str);
}

void Requirable::activate()
{
  m_b = true;
}

bool Requirable::isActive()
{
  return m_b;
}

const char* Requirable::getStr()
{
  return m_str;
}
